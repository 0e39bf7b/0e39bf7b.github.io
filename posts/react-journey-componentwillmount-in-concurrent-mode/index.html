<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.102.3" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2019-12-17">
  <meta property="og:title" content="React Journey: componentWillMount in Concurrent Mode &middot; Developer&#39;s blog">
  <meta name="description" content="Several days ago I was updating one of my React projects and I found deprecation warning like:

Warning: componentWillMount has been renamed, and is not recommended for use. See
https://fb.me/react-unsafe-component-lifecycles for details.

Move code with side effects to componentDidMount, and set initial state in the constructor.
Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict
mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their
new names, you can run npx react-codemod rename-unsafe-lifecycles in your project source folder.


I had followed the link from this warning and
found such an explanation about why this method is deprecated:

One of the biggest lessons we’ve learned is that some of our legacy component lifecycles tend to
encourage unsafe coding practices. They are:

componentWillMount
componentWillReceiveProps
componentWillUpdate

These lifecycle methods have often been misunderstood and subtly misused; furthermore, we
anticipate that their potential misuse may be more problematic with async rendering.

I think it&rsquo;s important to understand why using componentWillMount callback can be unsafe and why
you need to change your code somehow. First of all, let&rsquo;s find out different usage examples of
componentWillMount callback and check if it is safe or not to use this callback in different
situations in the stable version of React 16.12.0 for browser rendering (there are some issues
with server rendering but it&rsquo;s a subject of a separate article).">
  <meta property="og:description" content="Several days ago I was updating one of my React projects and I found deprecation warning like:

Warning: componentWillMount has been renamed, and is not recommended for use. See
https://fb.me/react-unsafe-component-lifecycles for details.

Move code with side effects to componentDidMount, and set initial state in the constructor.
Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict
mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their
new names, you can run npx react-codemod rename-unsafe-lifecycles in your project source folder.


I had followed the link from this warning and
found such an explanation about why this method is deprecated:

One of the biggest lessons we’ve learned is that some of our legacy component lifecycles tend to
encourage unsafe coding practices. They are:

componentWillMount
componentWillReceiveProps
componentWillUpdate

These lifecycle methods have often been misunderstood and subtly misused; furthermore, we
anticipate that their potential misuse may be more problematic with async rendering.

I think it&rsquo;s important to understand why using componentWillMount callback can be unsafe and why
you need to change your code somehow. First of all, let&rsquo;s find out different usage examples of
componentWillMount callback and check if it is safe or not to use this callback in different
situations in the stable version of React 16.12.0 for browser rendering (there are some issues
with server rendering but it&rsquo;s a subject of a separate article).">
  <title>React Journey: componentWillMount in Concurrent Mode &middot; Developer&#39;s blog</title>
  

  
  <link type="text/css" rel="stylesheet" href="../../css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="../../css/poole.css">
  <link type="text/css" rel="stylesheet" href="../../css/syntax.css">
  <link type="text/css" rel="stylesheet" href="../../css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Developer&#39;s blog" />
</head>

  <body>
    <header class="site-title">
      <h1><a href="../../">Developer&#39;s blog</a></h1>
      <h4><a href="../../notes">Go to Notes</a></h4>
    </header>
    <main class="container">
    <div class="post">
  <h1 class="post-title">React Journey: componentWillMount in Concurrent Mode</h1>
  <time datetime=2019-12-17T12:00:00Z class="post-date">Dec 17, 2019</time>
  <p>Several days ago I was updating one of my React projects and I found deprecation warning like:</p>
<blockquote>
<p>Warning: componentWillMount has been renamed, and is not recommended for use. See
<a href="https://fb.me/react-unsafe-component-lifecycles">https://fb.me/react-unsafe-component-lifecycles</a> for details.</p>
<ul>
<li>Move code with side effects to componentDidMount, and set initial state in the constructor.</li>
<li>Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict
mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their
new names, you can run <code>npx react-codemod rename-unsafe-lifecycles</code> in your project source folder.</li>
</ul>
</blockquote>
<p>I had followed <a href="https://fb.me/react-unsafe-component-lifecycles">the link from this warning</a> and
found such an explanation about why this method is deprecated:</p>
<blockquote>
<p>One of the biggest lessons we’ve learned is that some of our legacy component lifecycles tend to
encourage unsafe coding practices. They are:</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>These lifecycle methods have often been misunderstood and subtly misused; furthermore, we
anticipate that their potential misuse may be more problematic with async rendering.</p>
</blockquote>
<p>I think it&rsquo;s important to understand why using <code>componentWillMount</code> callback can be unsafe and why
you need to change your code somehow. First of all, let&rsquo;s find out different usage examples of
<code>componentWillMount</code> callback and check if it is safe or not to use this callback in different
situations in the stable version of React 16.12.0 for browser rendering (there are some issues
with server rendering but it&rsquo;s a subject of a separate article).</p>
<h3 id="initializing-state">Initializing state</h3>
<p>When a component needs initial state it can be provided like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">class</span> Counter <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentWillMount() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.setState({ value<span style="color:#719e07">:</span> <span style="color:#2aa198">0</span> });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this case, using <code>componentWillMount</code> is safe and it makes no troubles. It&rsquo;s possible to make
your code a bit more clear and use property initializer like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">class</span> Counter <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> { value<span style="color:#719e07">:</span> <span style="color:#2aa198">0</span> };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But I think there are no problems with <code>componentWillMount</code> here.</p>
<h3 id="fetching-external-data">Fetching external data</h3>
<p>Some components need external data from the server and it&rsquo;s possible to fetch it this way:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">class</span> TariffSelector <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> { tariffs<span style="color:#719e07">:</span> [] };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentWillMount() {
</span></span><span style="display:flex;"><span>    fetchTariffs().then(tariffs =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">this</span>.setState({ tariffs });
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> (
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#268bd2">select</span>&gt;
</span></span><span style="display:flex;"><span>        {<span style="color:#719e07">this</span>.tariffs.map(tariff =&gt; &lt;<span style="color:#268bd2">option</span> value<span style="color:#719e07">=</span>{tariff.value}&gt;{tariff.caption}&lt;/<span style="color:#268bd2">option</span>&gt;)}
</span></span><span style="display:flex;"><span>      &lt;/<span style="color:#268bd2">select</span>&gt;
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>React documentation says:</p>
<blockquote>
<p>The above code is problematic for both server rendering (where the external data won’t be used)
and the upcoming async rendering mode (where the request might be initiated multiple times).</p>
</blockquote>
<p>There are two different conceptions in React: async rendering and concurrent rendering. They are
similar but not the same. We&rsquo;ll discuss it later in more details but for now, I can say that there
are no problems with <code>componentWillMount</code> when we are talking about async rendering. The callback
will be called only once. Async rendering is enabled in React 16.12.0 by default. There can be
some troubles with <code>componentWillMount</code> when we are talking about
<a href="https://reactjs.org/docs/concurrent-mode-intro.html">concurrent rendering</a> but it&rsquo;s still
experimental and disabled in the current version of React by default.</p>
<p>It&rsquo;s important to remember that <code>componentWillMount</code> is a sync function so in the example above
the first call of <code>render</code> will be performed with empty <code>tariffs</code>. That is why it&rsquo;s essential to be
ready for such a case and provide some loading state if it is required.</p>
<h3 id="adding-event-listeners">Adding event listeners</h3>
<p>Some components subscribe to an external event dispatcher on the mount stage and unsubscribe on the
unmount stage:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">class</span> Chat <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  componentWillMount() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.props.chatService.subscribe(<span style="color:#2aa198">&#39;newMessage&#39;</span>, <span style="color:#719e07">this</span>.handleNewMessage);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentWillUnmount() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.props.chatService.unsubscribe(<span style="color:#2aa198">&#39;newMessage&#39;</span>, <span style="color:#719e07">this</span>.handleNewMessage);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  handleNewMessage <span style="color:#719e07">=</span> (msg) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.setState({ newMessage<span style="color:#719e07">:</span> msg });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As it is said in React documentation this code can be dangerous for server rendering and async
rendering mode. Actually, it&rsquo;s safe for async rendering mode and dangerous for concurrent mode.</p>
<p>Async rendering mode was mentioned several times in React documentation when talking about
<code>componentWillMount</code>. Let&rsquo;s talk a bit more about it.</p>
<h3 id="react-fiber-architecture-and-async-rendering">React Fiber Architecture and Async Rendering</h3>
<p>When you have a lot of components on the page rendering can take a lot of time but the browser has
to update screen 60 times per second to make animations and scrolling smooth. If the rendering takes
more than 16ms browser has to drop frames and animations look choppy. React 15 and older versions
perform rendering of the whole application as a single task that is why it was difficult to provide
good user experience for big applications.</p>
<p>In React 16 new Fiber Architecture was introduced. The idea is to split rendering into several
chunks and perform them independently. Let&rsquo;s take a look at the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">function</span> App() {
</span></span><span style="display:flex;"><span>  <span style="color:#719e07">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#268bd2">Header</span> /&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#268bd2">Content</span> /&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">function</span> Header() {
</span></span><span style="display:flex;"><span>  <span style="color:#719e07">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#268bd2">header</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#268bd2">h1</span>&gt;My Application&lt;/<span style="color:#268bd2">h1</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#268bd2">header</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">class</span> Content <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> { article<span style="color:#719e07">:</span> <span style="color:#cb4b16">null</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentDidMount() {
</span></span><span style="display:flex;"><span>    fetchArticle().then(article =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">this</span>.setState({ article });
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">this</span>.state.article) {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">return</span> &lt;<span style="color:#268bd2">div</span> className<span style="color:#719e07">=</span>{<span style="color:#2aa198">&#39;content&#39;</span>}&gt;{<span style="color:#719e07">this</span>.state.article}&lt;/<span style="color:#268bd2">div</span>&gt;;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> <span style="color:#cb4b16">null</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(&lt;<span style="color:#268bd2">App</span> /&gt;, <span style="color:#b58900">document</span>.getElementById(<span style="color:#2aa198">&#39;root&#39;</span>));
</span></span></code></pre></div><p>To understand how this code works, first of all, let&rsquo;s remove jsx and see how this code will look
like:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#268bd2">function</span> App() {
</span></span><span style="display:flex;"><span>  <span style="color:#719e07">return</span> React.createElement(
</span></span><span style="display:flex;"><span>    <span style="color:#2aa198">&#39;div&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#cb4b16">null</span>,
</span></span><span style="display:flex;"><span>    React.createElement(
</span></span><span style="display:flex;"><span>      Header,
</span></span><span style="display:flex;"><span>      <span style="color:#cb4b16">null</span>
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    React.createElement(
</span></span><span style="display:flex;"><span>      Content,
</span></span><span style="display:flex;"><span>      <span style="color:#cb4b16">null</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">function</span> Header() {
</span></span><span style="display:flex;"><span>  <span style="color:#719e07">return</span> React.createElement(
</span></span><span style="display:flex;"><span>    <span style="color:#2aa198">&#39;header&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#cb4b16">null</span>,
</span></span><span style="display:flex;"><span>    React.createElement(
</span></span><span style="display:flex;"><span>      <span style="color:#2aa198">&#39;h1&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#cb4b16">null</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#2aa198">&#39;My Application&#39;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">class</span> Content <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> { article<span style="color:#719e07">:</span> <span style="color:#cb4b16">null</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentDidMount() {
</span></span><span style="display:flex;"><span>    fetchArticle().then(article =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">this</span>.setState({
</span></span><span style="display:flex;"><span>        article
</span></span><span style="display:flex;"><span>      });
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">this</span>.state.article) {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">return</span> React.createElement(
</span></span><span style="display:flex;"><span>        <span style="color:#2aa198">&#39;div&#39;</span>, {
</span></span><span style="display:flex;"><span>        className<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;content&#39;</span>
</span></span><span style="display:flex;"><span>      }, <span style="color:#719e07">this</span>.state.article);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> <span style="color:#cb4b16">null</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(React.createElement(App, <span style="color:#cb4b16">null</span>), <span style="color:#b58900">document</span>.getElementById(<span style="color:#2aa198">&#39;root&#39;</span>));
</span></span></code></pre></div><p>As you can see React creates elements using <code>createElement</code> function. This function returns plain
JS object like:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  type<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;h1&#39;</span>,
</span></span><span style="display:flex;"><span>  props<span style="color:#719e07">:</span> {
</span></span><span style="display:flex;"><span>    children<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;My Application&#39;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can find more information about this topic in
<a href="https://reactjs.org/docs/introducing-jsx.html">Introducing JSX</a> article.</p>
<p>To build the final virtual DOM React needs to perform several steps.</p>
<p><strong>Step 1:</strong> convert</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  type<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;App&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>into</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  type<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;div&#39;</span>,
</span></span><span style="display:flex;"><span>  props<span style="color:#719e07">:</span> {
</span></span><span style="display:flex;"><span>    children<span style="color:#719e07">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        type<span style="color:#719e07">:</span> Header
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        type<span style="color:#719e07">:</span> Content
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Step 2:</strong> convert <code>Header</code> child into</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  type<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;header&#39;</span>,
</span></span><span style="display:flex;"><span>  props<span style="color:#719e07">:</span> {
</span></span><span style="display:flex;"><span>    children<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;My Application&#39;</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p><strong>Step 3:</strong> create instance of <code>Content</code> class and call it&rsquo;s <code>render</code> function. It returns <code>null</code>
because data is loaded asynchronously in the <code>componentDidUpdate</code> hook.</p>
<p><strong>Step 4:</strong> in response to <code>setState</code> update state and call <code>render</code> for <code>Content</code> class instance
again what will lead to final result like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  type<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;div&#39;</span>,
</span></span><span style="display:flex;"><span>  props<span style="color:#719e07">:</span> {
</span></span><span style="display:flex;"><span>    className<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;content&#39;</span>,
</span></span><span style="display:flex;"><span>    children<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;Hello world&#39;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After these steps React can get final virtual DOM and perform changes in the browser&rsquo;s DOM. The
process described above is called <a href="https://reactjs.org/docs/reconciliation.html">Reconciliation</a>.</p>
<p>In React 15 and earlier versions steps 1 - 3 processed synchronously as a single task. It&rsquo;s OK
for simple cases but when a component tree is big enough it can become a problem.</p>
<p>In React 16 Fiber Architecture was introduced. This approach treats each step as a separate task
that is why rendering can be paused and the browser can process animations. It makes the application
more smooth and responsive. <a href="https://github.com/acdlite">Andrew Clark</a> wrote
<a href="https://github.com/acdlite/react-fiber-architecture">a good description of Fiber Architecture</a> and
also present it on ReactNext 2016: <a href="https://youtu.be/aV1271hd9ew">https://youtu.be/aV1271hd9ew</a>.</p>
<p>Even more detailed explanation can be found in a post by
<a href="https://blog.ag-grid.com/author/maxkoretskyi/">Max Koretskyi</a>
<a href="https://blog.ag-grid.com/inside-fiber-an-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/">Inside Fiber: an in-depth overview of the new reconciliation algorithm in React</a>.
It&rsquo;s definitely worth reading.</p>
<p>There was a lot of information about Fiber during React Conf 2017. You can find
<a href="https://www.youtube.com/playlist?list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0">records of the conference on youtube</a>.</p>
<p>And of course, the best way to understand Fiber Architecture is by exploring the code of React.
You can create a small application set breakpoints and follow the execution step by step. A lot of
interesting things can be found this way.</p>
<p>For now, you need to remember that React uses Fiber Architecture. It splits rendering into pieces
and executes each piece asynchronously until all work is done. There is a task queue and new tasks
are added into the end of it.</p>
<h3 id="concurrent-mode">Concurrent Mode</h3>
<p>As it was said earlier React splits reconciliation into pieces and executes them one by one. It
solves the problem of choppy animations because rendering is interruptible for browser tasks but
it does not solve the problem of responsiveness. Let&rsquo;s take a look at the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">class</span> ArticlesList {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> {
</span></span><span style="display:flex;"><span>    articles<span style="color:#719e07">:</span> [],
</span></span><span style="display:flex;"><span>    filter<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  handleFilter <span style="color:#719e07">=</span> (event) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.setState({ filter<span style="color:#719e07">:</span> event.target.value });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentDidMount() {
</span></span><span style="display:flex;"><span>    fetchArticles().then(articles =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">this</span>.setState({ articles });
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#268bd2">const</span> { articles, filter } <span style="color:#719e07">=</span> <span style="color:#719e07">this</span>.state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> (
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#268bd2">input</span> type<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;text&#34;</span> name<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;filter&#34;</span> onChange<span style="color:#719e07">=</span>{<span style="color:#719e07">this</span>.handleFilter} /&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>          {applyFilter(articles, filter).map(article =&gt; &lt;<span style="color:#268bd2">Article</span> data<span style="color:#719e07">=</span>{article} /&gt;)}
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;/<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Assume there are a lot of articles and the rendering takes a lot of time. If a user changes the
filter value new task for updating the interface will be enqueued but it will be executed only after
the current rendering will be finished. Such behavior makes the user experience poor that is why
developers have to use different approaches (e.g. debouncing) to solve this problem.</p>
<p>React has an experimental feature called
<a href="https://reactjs.org/docs/concurrent-mode-intro.html">Concurrent Mode</a>. It defines
<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/SchedulerWithReactIntegration.js#L58-L64">priorities</a>
and allows rendering with lower priority to be interrupted by rendering with higher priority. So it
is possible to work on multiple tasks at the same time and switch between them according to their
priority. E.g.  immediate response to user input is more important than updating interface after
fetching data from the network.</p>
<p>How Concurrent Mode works?</p>
<ol>
<li>split rendering into pieces;</li>
<li>process each piece but do not update the interface;</li>
<li>when work is done - update interface.</li>
</ol>
<p>React docs comparing this with SCM like Git when developer create a separate branch for some
feature, work on in and then merge it into the main branch of the project.</p>
<p>What if the user clicks some button during long rendering? In this case, React pauses current
rendering and initializes new one for a processing button click, commits new rendering results into
the browser&rsquo;s DOM and returns to processing long rendering. If it&rsquo;s not possible to continue long
rendering it will be restarted.</p>
<p>This example illustrates Concurrent Mode in action:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#268bd2">let</span> lastCounter <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; <span style="color:#586e75">// Global variable for multiple mounts detection
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">class</span> Counter <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  componentWillMount() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">if</span> (lastCounter <span style="color:#719e07">===</span> <span style="color:#719e07">this</span>.props.value) {
</span></span><span style="display:flex;"><span>      console.log(<span style="color:#586e75">`mount counter with value = </span><span style="color:#2aa198">${</span><span style="color:#719e07">this</span>.props.value<span style="color:#2aa198">}</span><span style="color:#586e75"> multiple times`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    lastCounter <span style="color:#719e07">=</span> <span style="color:#719e07">this</span>.props.value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// Syncronously wait for 100ms to emulate long work
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    <span style="color:#268bd2">const</span> start <span style="color:#719e07">=</span> <span style="color:#b58900">Date</span>.now();
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">while</span> (<span style="color:#b58900">Date</span>.now() <span style="color:#719e07">-</span> start <span style="color:#719e07">&lt;</span> <span style="color:#2aa198">100</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> &lt;<span style="color:#268bd2">div</span>&gt;{<span style="color:#719e07">this</span>.props.value}&lt;/<span style="color:#268bd2">div</span>&gt;;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">class</span> App <span style="color:#268bd2">extends</span> React.Component {
</span></span><span style="display:flex;"><span>  state <span style="color:#719e07">=</span> { counter<span style="color:#719e07">:</span> <span style="color:#2aa198">0</span>, showGreetings<span style="color:#719e07">:</span> <span style="color:#cb4b16">true</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentDidMount() {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.interval <span style="color:#719e07">=</span> setInterval(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#719e07">this</span>.setState({ counter<span style="color:#719e07">:</span> <span style="color:#719e07">this</span>.state.counter <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span> });
</span></span><span style="display:flex;"><span>    }, <span style="color:#2aa198">500</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  componentWillUnmount() {
</span></span><span style="display:flex;"><span>    clearInterval(<span style="color:#719e07">this</span>.interval);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  toggleGreetings <span style="color:#719e07">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">this</span>.setState({ showGreetings<span style="color:#719e07">:</span> <span style="color:#719e07">!</span><span style="color:#719e07">this</span>.state.showGreetings });
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// Use key attribute to force React to remount Counter component
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    <span style="color:#719e07">return</span> (
</span></span><span style="display:flex;"><span>      &lt;&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#268bd2">button</span> onClick<span style="color:#719e07">=</span>{<span style="color:#719e07">this</span>.toggleGreetings}&gt;Toggle greetings&lt;/<span style="color:#268bd2">button</span>&gt;
</span></span><span style="display:flex;"><span>        {<span style="color:#719e07">this</span>.state.showGreetings <span style="color:#719e07">&amp;&amp;</span> &lt;<span style="color:#268bd2">h1</span>&gt;Hello world<span style="color:#719e07">!</span>&lt;/<span style="color:#268bd2">h1</span>&gt;}
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#268bd2">Counter</span> value<span style="color:#719e07">=</span>{<span style="color:#719e07">this</span>.state.counter} key<span style="color:#719e07">=</span>{<span style="color:#586e75">`counter-</span><span style="color:#2aa198">${</span><span style="color:#719e07">this</span>.state.counter<span style="color:#2aa198">}</span><span style="color:#586e75">`</span>} /&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#268bd2">div</span>&gt;{<span style="color:#719e07">this</span>.state.counter2}&lt;/<span style="color:#268bd2">div</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;/&gt;
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// Instead of regular initialization
</span></span></span><span style="display:flex;"><span><span style="color:#586e75">// ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));
</span></span></span><span style="display:flex;"><span><span style="color:#586e75">// use Concurrent Rendering for this component
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>ReactDOM.createRoot(<span style="color:#b58900">document</span>.getElementById(<span style="color:#2aa198">&#39;root&#39;</span>)).render(&lt;<span style="color:#268bd2">App</span> /&gt;);
</span></span></code></pre></div><p>There is a counter increased with <code>setInterval</code> every 500ms. Every change of the counter initiate
rendering of the <code>App</code> component and as a result - remounting and rendering of the <code>Counter</code>
component. There is a button that can be used to hide and show greetings caption. It means that
clicking on the button initiate rendering of the <code>App</code> component. Rendering initiated by button
click has higher priority than rendering initiated by <code>setInterval</code>. Rendering of the <code>Counter</code>
component splits into several steps:</p>
<ol>
<li><a href="https://github.com/facebook/react/blob/0253ee9a2e94d43e220a997eeedfcc6847c4542b/packages/react-reconciler/src/ReactFiberClassComponent.js#L525">constructClassInstance</a>;</li>
<li><a href="https://github.com/facebook/react/blob/0253ee9a2e94d43e220a997eeedfcc6847c4542b/packages/react-reconciler/src/ReactFiberClassComponent.js#L760">mountClassIntance</a>;</li>
<li><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberBeginWork.js#L853">render</a>;</li>
<li>reconciling children.</li>
</ol>
<p>Steps 1 - 2 performed one after another as a single chunk of work for React. Step 3 is a separate
chunk. Step 4 is a separate chunk of work but for complex components, it can lead to several chunks
of work.</p>
<p>Rendering of the <code>Counter</code> component can be interrupted after step 2. In this case, React needs
to restart mounting. You can run the example above on the local machine or online service like
<a href="https://codesandbox.io/">https://codesandbox.io/</a> and click the button multiple times. It&rsquo;s possible that you will see
something like this in the browser console:</p>
<blockquote>
<p>mount counter with value = 10 multiple times</p>
</blockquote>
<p>It means <code>Counter</code> rendering was interrupted and restarted. In this case, <code>componentWillMount</code> is
called several times, but for each time new class instance will be created, so it&rsquo;s better to say
that <code>constructor</code> + <code>componentWillMount</code> will be called several times.</p>
<p>When is it unsafe?</p>
<ul>
<li>when component subscribes to some events in <code>componentWillMount</code> and unsubscribes in
<code>componentWillUnmount</code> (it can be a memory leak because <code>componentWillUnmount</code> is not called if
rendering was interrupted);</li>
<li>if it&rsquo;s required to perform some code only once (e.g. some request to the server or modifying
global state).</li>
</ul>
<p>That is why you need to be aware of these possible technical difficulties using
<code>componentWillMount</code> (or <code>UNSAFE_componentWillMount</code>) with Concurrent Mode.</p>
<p>There are some interesting videos devoted to this subject:</p>
<ul>
<li><a href="https://youtu.be/nLF0n9SACd4">Dan Abramov: Beyond React 16 | JSConf Iceland 2018</a>;</li>
<li><a href="https://youtu.be/ByBPyMBTzM0">Concurrent Rendering in React - Andrew Clark and Brian Vaughn - React Conf 2018</a>.</li>
</ul>
<p>Coming to a conclusion I want to mention several points:</p>
<ul>
<li>it&rsquo;s safe to use <code>componentWillMount</code> in React 16.12.0;</li>
<li>it&rsquo;s unsafe to use <code>componentWillMount</code> with Concurrent Mode;</li>
<li><code>componentWillMount</code> can be replaced with more suitable solutions in most cases.</li>
</ul>
</div>
    </main>
  </body>
</html>
